@startuml

abstract class Player
abstract class Game
abstract class Table
Interface GameEvent

class Dealer

class Bet
class Outcome

class Card
class FaceCard
class AceCard
class Card_Factory << (F, #FF7700) focus >>

class Deck

abstract class Hand
class BlackjackHand << type >>
class BlackjackHandHardScore
class BlackjackHandSoftScore

class BlackjackTable

class BlackjackPlayer

class BlackjackGame

Bet *-- Outcome

Dealer *-- Deck : contains

Card <|-- FaceCard
Card <|-- AceCard
Card_Factory ..|> FaceCard : << creates >>
Card_Factory ..|> Card : << creates >>
Card_Factory ..|> AceCard : << creates >>

AceCard <-- BlackjackHand

Deck "52" *-- "*" Card : << contains l>>

BlackjackHand "*" *-- "1" BlackjackHandSoftScore : << call >>
BlackjackHand "*" *-- "1" BlackjackHandHardScore : << call >>

GameEvent <|-- Hand
Hand <|-- BlackjackHand

Table <|-- BlackjackTable
BlackjackTable <-- Bet
BlackjackTable <-- Hand

Player <|-- BlackjackPlayer
BlackjackPlayer <-- Table
BlackjackPlayer <-- Hand

Game <|-- BlackjackGame

note left of BlackjackHand: A BlackjackHand has two states: Hard aces and soft aces.

note left of BlackjackTable: A Table that handles association\nbetween Bet (s) and specific Hands

note top of GameEvent : The interface GameEvent\ndefines the setup for the\nHand (s) on which a\nplayer bets
note top of Player : The base class of a Player
note top of Table : Table contains all the Bet(s)\ncreated by the Player
note top of Game: Game manages a sequence\nactions that define the\ngame of Blackjack

note left of Bet : Every Bet has an Outcome

note top of Card_Factory : Focus classes contain primary\nlogic and support other\nclasses.

abstract class Game {
WagerEvent wager
Table table
Player player
Game(wager, table) «constructor»
cycle(player)
}


abstract class Player {
int stake
Table table
Player(table) «constructor»
playing()
placeBet()
win(bet)
lose(bet)
}

interface GameEvent {
Outcome[] outcomes
}

class Card {
int rank
int suit
Card(rank, suit) «constructor»
toString()
}

class AceCard {
setCardScore(Hand)
}

class Deck {
Card cards[]
Deck() «constructor»
getCards()
}

class Dealer {
deal[]
Dealer(decks) «constructor»
shuffle()
iterator()
}

abstract class Hand {
Outcome outcome
Player handOwner
Card[] cards
Hand()
setBet(Bet)
}

class BlackjackTable {
BlackjackHand() «constructor»
placeBet(Bet, Hand)
}

class BlackjackHand {
Outcome outcome
Card[] cards
BlackjackHandHardScore hardScore
BlackjackHandSoftScore softScore
lowestScore
BlackjackHand()
BlackjackHand(Card)
add(Card)
highestScore()
size()
blackjack()
busted()
toString()
}

class BlackjackHandSoftScore {
BlackjackHandSoftScore(Card)
}

class BlackjackHandHardScore {
BlackjackHandHardScore(Card)
}

class BlackjackPlayer {
Hand playerHand
BlackjackPlayer(Table)
newGame()
placeBet()
getStartingHand()
boolean doubleDown(Hand)
boolean hit(Hand)
}


enum TimeUnit {
DAYS
HOURS
MINUTES
}

@enduml